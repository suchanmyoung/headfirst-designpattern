* 전략패턴 
  * 오리의 행위를 인터페이스화 하고, 구체적인 오리를 생성할 때 구체적인 행위를 생성하는 방식
  * A에는 B가 있다.
  * 행동을 위임
  * 검색 버튼을 예로 들면, SearchStrategy Interface 만들고, 각각의 구현체(image, news, map 등)을 만든다.
  그리고 SearchButton 의 setter()를 호출 시 구현체를 생성하여 전략을 갈아끼움.
* 옵저버패턴
  * 주제 인터페이스를 구현하는 객체가 변하면(set 메소드의 동작 등) notifyObserver 메소드로 모든 옵저버들에게 연락. 옵저버들은 생성자를 호출할 때
  주제 객체를 매개변수로 받아와서 등록.
* 데코레이터패턴
  * 하나의 추상 클래스(혹은 인터페이스)를 상속(혹은 구현) 받은 객체 간에 추가 요소를 동적으로 더하는 방식
  * new Mocha(new Mocha(new DarkRoast)) 와 같은 코드로 실행되는데, 이때 재귀적으로 내부에서 동작한다!
* 팩토리 메소드 패턴
  * 객체 생성을 처리하는 팩토리(추상 클래스)를 선언하고, 추상 메소드를 통해 팩토리에 접근하여 구체적인 팩토리가 객체 생성을 구현한다. 
  * 매개변수 팩토리 메소드를 사용하면 엉뚱한 에러(오타 등)이 나타날 수 있는데, 이때 컴파일 단계에서 에러를 잡으려면 ENUM 이나 정적 상수를 쓸수 있다.
* 싱글턴패턴
  * 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴
  * 만약 멀티 스레드의 영향으로 고전적인 싱글턴 패턴에서 두 개의 인스턴스가 생성 되어버린다면?
    * synchronized(한 스레드가 메소드 사용을 끝내기 전까지 다른 스레드는 기다려야 함) 사용(성능 이슈가 없다면 사용, 하지만 100배 정도 성능 느려짐)
    * 게으른 인스턴스 생성을 포기하고, 처음부터 private static Singleton uniqueInstance = new Singleton(); 으로 생성해버림
* 커맨드패턴
  * 요청 내역을 객체로 캡슐화, 클라이언트를 서로 다른 요청 내역에 따라 매개변수화
  * 커맨드패턴은 다시 학습해야할듯
* 어댑터패턴
  * 한 인터페이스를 다른 인터페이스로 변환해주는 역할
  * 호출하는 메소드가 있는 곳이 타겟 인터페이스, 어댑터 덕분에 타겟 인터페이스에 붙여서 사용할 수 있는게 어댑티 -> 실제로 사용해야 하는 게 타겟 인터페이스!
* 퍼싸드패턴
  * 시스템의 일련의 프로세스를 간단하게 사용할 수 있는 인터페이스를 제공
  * 어댑터 패턴은 인터페이스를 변경해서 클라이언트에서 필요로 하는 인터페이스로 적응시키는 용도, 퍼싸드는 어떤 시스템에 대한 간단한 인터페이스를 제공하는 용도
